package edu.teco.dnd.server;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import edu.teco.dnd.discover.ModuleQuery;
import edu.teco.dnd.module.ModuleInfo;
import edu.teco.dnd.network.ConnectionListener;
import edu.teco.dnd.network.ConnectionManager;
import edu.teco.dnd.network.UDPMulticastBeacon;
import edu.teco.dnd.util.FutureListener;
import edu.teco.dnd.util.FutureNotifier;
import edu.teco.dnd.util.JoinedFutureNotifier;

/**
 * This class coordinates a List of currently running modules. It provides module information to
 * display to the user.
 * 
 * @author jung
 * 
 */
public class ModuleManager implements ConnectionListener, ServerStateListener,
		FutureListener<FutureNotifier<ModuleInfo>> {
	/**
	 * A Map of all Modules that were found. Modules are added with a value of null when they're discovered, after the
	 * ModuleInfo responded to the RequestModuleInfoMessage the value is updated.
	 */
	private Map<UUID, ModuleInfo> map;

	/**
	 * All registered listeners.
	 */
	private final Set<ModuleManagerListener> moduleManagerListeners = new HashSet<ModuleManagerListener>();

	/**
	 * The currently running ConnectionManager.
	 */
	private ConnectionManager connectionManager;

	/**
	 * The ModuleQuery that is used to query information about the Modules.
	 */
	private ModuleQuery query;

	/**
	 * Initializes a new ModuleManager.
	 */
	protected ModuleManager() {
		map = new HashMap<UUID, ModuleInfo>();
		ServerManager.getDefault().addServerStateListener(this);
	}

	/**
	 * Registers a new ModuleManagerListener. ModuleManagerListeners can only be registered once, if this method is
	 * called multiple times with the same argument the listener will still only be called once for every event.
	 * 
	 * @param listener
	 *            the ModuleManagerListener to add
	 */
	public synchronized void addModuleManagerListener(final ModuleManagerListener listener) {
		moduleManagerListeners.add(listener);
		if (connectionManager == null) {
			listener.serverOffline();
		} else {
			listener.serverOnline(map);
		}
	}

	/**
	 * Removes a ModuleManagerListener. The ModuleManagerListener will no longer receive events generated by this
	 * ModuleManager, even if {@link #addModuleManagerListener(ModuleManagerListener)} was called multiple times. If the
	 * listener was not registered nothing is done.
	 * 
	 * @param listener
	 *            the listener to remove
	 */
	public synchronized void removeModuleManagerListener(final ModuleManagerListener listener) {
		moduleManagerListeners.remove(listener);
	}
	
	@Override
	public void serverStateChanged(final ServerState state, final ConnectionManager connectionManager, final UDPMulticastBeacon beacon) {
		switch (state) {
		case RUNNING:
			serverStarted(connectionManager);
			break;
			
		case STOPPED:
			serverStopped();
			break;
		}
	}

	private synchronized void serverStarted(ConnectionManager newConnectionManager) {
		if (connectionManager != null) {
			connectionManager.removeConnectionListener(this);
		}
		map.clear();

		connectionManager = newConnectionManager;
		connectionManager.addConnectionListener(this);
		query = new ModuleQuery(connectionManager);
		Collection<UUID> modules = connectionManager.getConnectedModules();

		for (UUID id : modules) {
			map.put(id, null);
			query.getModuleInfo(id).addListener(this);
		}

		for (final ModuleManagerListener listener : moduleManagerListeners) {
			listener.serverOnline(map);
		}
	}

	private synchronized void serverStopped() {
		if (connectionManager != null) {
			connectionManager.removeConnectionListener(this);
		}

		for (final ModuleManagerListener listener : moduleManagerListeners) {
			listener.serverOffline();
		}
		
		map.clear();
	}

	@Override
	public synchronized void connectionEstablished(UUID uuid) {
		map.put(uuid, null);
		query.getModuleInfo(uuid).addListener(this);

		for (final ModuleManagerListener listener : moduleManagerListeners) {
			listener.moduleOnline(uuid);
		}
	}

	@Override
	public synchronized void connectionClosed(UUID uuid) {
		ModuleInfo mod = map.get(uuid);
		map.remove(uuid);
		
		for (final ModuleManagerListener listener : moduleManagerListeners) {
			listener.moduleOffline(uuid, mod);
		}
	}

	@Override
	public synchronized void operationComplete(FutureNotifier<ModuleInfo> future) throws Exception {
		if (future.isSuccess()) {
			ModuleInfo module = future.getNow();
			UUID id = module.getUUID();
			map.put(id, module);
			for (final ModuleManagerListener listener : moduleManagerListeners) {
				listener.moduleResolved(id, module);
			}
		}

	}

	/**
	 * Returns a copy of the Map of all currently known Modules. The value for an entry may be null if the ModuleInfo hasn't
	 * responded to the RequestModuleInfoMessage yet.
	 * 
	 * @return a copy of the Map of all currently known Modules
	 */
	public synchronized Map<UUID, ModuleInfo> getMap() {
		return new HashMap<UUID, ModuleInfo>(map);
	}

	/**
	 * Returns a Collection of currently running modules that are already resolved. Does not contain modules that
	 * haven't been resolved from their UUID yet.
	 * 
	 * @return collection of currently running modules to deploy on.
	 */
	public Collection<ModuleInfo> getModuleCollection() {
		Collection<ModuleInfo> collection = new ArrayList<ModuleInfo>();
		for (UUID id : map.keySet()) {
			ModuleInfo m = map.get(id);
			if (m != null) {
				collection.add(m);
			}
		}
		return collection;
	}
	
	/**
	 * Updates information on modules, in explicit how the BlockTypeHolder has changed and which applications are
	 * running on the module.
	 * 
	 * @return
	 */
	public synchronized FutureNotifier<Collection<ModuleInfo>> updateModuleInfo() {
		final Collection<FutureNotifier<? extends ModuleInfo>> futures = new ArrayList<FutureNotifier<? extends ModuleInfo>>();
		for (UUID uuid : map.keySet()) {
			final FutureNotifier<ModuleInfo> future = query.getModuleInfo(uuid);
			future.addListener(this);
			futures.add(future);
		}
		return new JoinedFutureNotifier<ModuleInfo>(futures);
	}

}
