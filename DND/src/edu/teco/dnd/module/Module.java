package edu.teco.dnd.module;

import java.io.IOException;
import java.io.Serializable;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import lime.AgentCreationException;
import lime.LimeServer;
import lime.PropertyKeys;

import edu.teco.dnd.blocks.FunctionBlock;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * The main class that is started on a Module.
 */
public class Module implements Serializable {
	/**
	 * The logger for this class.
	 */
	private static final Logger LOGGER = LogManager.getLogger(Module.class);

	/**
	 * Default path for config file.
	 */
	public static final String DEFAULT_CONFIG_PATH = "./module.cfg";

	/**
	 * Used for serialization.
	 */
	private static final long serialVersionUID = -6539445515081628961L;

	/**
	 * Maximal number of supported ports.
	 */
	private static final int MAX_PORT_NUMBER = 65535;

	/**
	 * The module this program is running on or null.
	 */
	private static Module localModule = null;

	/**
	 * wheather to give an easy way to shut down by pressing a key in the console.
	 */
	private static boolean interactive = false;

	/**
	 * The ModuleConfig describing this module.
	 */
	private ModuleConfig moduleConfig = null;

	/**
	 * The communicationAgent used by this module. Will be null if this is not the local module.
	 */
	private transient CommunicationAgent communicationAgent = null;

	/**
	 * The id of this module. Generated by the CommunicationAgent.
	 */
	private long id = 0L;

	/**
	 * A list of FunctionBlock identifiers that can be run on this Module. Does not include identifiers that
	 * are in use.
	 */
	private List<String> canRun = new LinkedList<String>();

	/**
	 * A list of FunctionBlock identifiers that are currently in use.
	 */
	private List<String> isRunning = new LinkedList<String>();

	/**
	 * location of this module.
	 */
	private String location = "notGiven";

	/**
	 * Returns the module object representing the Module this program is running on or null if this is not a
	 * running module.
	 * 
	 * @return the module object this program is running on or null
	 */
	public static Module getLocalModule() {
		return Module.localModule;
	}

	/**
	 * Reads a ModuleConfig, sets the Module for {@link #getLocalModule()} and starts a
	 * {@link CommunicationAgent}.
	 * 
	 * @param args
	 *            command line arguments <br>
	 *            -first parameter signifies path to config file.
	 */
	public static void main(final String[] args) {
		String configPath = DEFAULT_CONFIG_PATH;
		InetAddress ip = null;
		int port = Integer.MIN_VALUE;
		NetworkInterface mcastif = null;
		int i = 0;
		LOGGER.trace("starting argument parsing. {} arguments to parse.", args.length);
		while (i < args.length) {
			LOGGER.debug("argument {} is \"{}\"", i, args[i]);
			switch (args[i]) {
			case "-h":
			case "--help":
				System.out.println("Parameters:");
				System.out.println("-c file, --config file:\tset config file to use");
				System.out.println("-i ip, --ip ip:\tset ip address to use");
				System.out
						.println("-n if, --network-interface if:\tset network interface to use ( e.g. \"eth0\")");
				System.out.println("-p port, --port port\tset base port");
				System.out.println("--interactive\tenable interactive mode");
				System.exit(0);
				break;
			case "-c":
			case "--config":
				if (args.length <= i + 1) {
					LOGGER.fatal("Missing parameter for \"{}\"", args[i]);
					System.exit(1);
				}
				configPath = args[i + 1];
				LOGGER.trace("configuration path is now \"{}\"", configPath);
				i += 2;
				break;
			case "-p":
			case "--port":
				if (args.length <= i + 1) {
					LOGGER.fatal("Missing parameter for \"{}\"", args[i]);
					System.exit(1);
				}
				port = Integer.MIN_VALUE;
				try {
					port = Integer.parseInt(args[i + 1]);
				} catch (NumberFormatException e) {
				}
				if (port <= 0 || port > MAX_PORT_NUMBER) {
					LOGGER.fatal("Invalid port");
					System.exit(1);
				}
				i += 2;
				break;
			case "-i":
			case "--ip":
				if (args.length <= i + 1) {
					LOGGER.fatal("Missing parameter for \"{}\"", args[i]);
					System.exit(1);
				}
				try {
					ip = InetAddress.getByName(args[i + 1]);
				} catch (UnknownHostException e) {
					LOGGER.catching(e);
					LOGGER.fatal("Invalid ip address");
					System.exit(1);
				}
				LOGGER.trace("ip address is now \"{}\"", ip);
				i += 2;
				break;
			case "-n":
			case "--network-interface":
				if (args.length <= i + 1) {
					LOGGER.error("Missing parameter for \"{}\"", args[i]);
					System.exit(1);
				}
				try {
					mcastif = NetworkInterface.getByName(args[i + 1]);
				} catch (SocketException e) {
					LOGGER.catching(Level.INFO, e);
					mcastif = null;
				}
				if (mcastif == null) {
					LOGGER.error("invalid network interface");
					System.exit(1);
				}
				LOGGER.trace("network interface is now \"{}\"", mcastif);
				i += 2;
				break;
			case "--interactive":
				interactive = true;
				LOGGER.trace("Enabled Interactive mode.");
				i++;
				break;
			default:
				LOGGER.error("unknown parameter: \"{}\"", args[i]);
				System.exit(1);
				break;
			}
		}

		LimeServer server = LimeServer.getServer();
		server.setProperty(PropertyKeys.GM_DETECTORkey, "Beaconing");
		if (ip != null) {
			LOGGER.trace("setting local address to {}", ip);
			server.setProperty(PropertyKeys.LOCALADDRkey, ip.getHostAddress());
		}
		if (mcastif != null) {
			LOGGER.trace("setting multicast interface to {}", mcastif);
			server.setProperty(PropertyKeys.GM_MCASTIFkey, mcastif.getName());
		}
		if (port > 0 && port <= MAX_PORT_NUMBER) {
			server.setProperty(PropertyKeys.PORTkey, String.valueOf(port));
		}

		LOGGER.info("booting LimeServer");
		server.boot();

		try {
			localModule = new Module(configPath);
		} catch (IOException e) {
			LOGGER.fatal("Cannot read config file.");
			LOGGER.catching(e);
			System.exit(2);
		}

		LOGGER.info("Loading CommunicationAgent");
		try {
			localModule.communicationAgent = (CommunicationAgent) server.loadAgent(
					CommunicationAgent.class.getCanonicalName(), null);
		} catch (AgentCreationException e) {
			LOGGER.catching(e);
			System.exit(2);
		}

		if (interactive) {
			try {
				System.in.read();
			} catch (IOException e) {
				LOGGER.fatal("running interactive without a console.");
				LOGGER.catching(e);
			}
			LOGGER.info("shutting down server (this should only happen while debugging)");

			if (Module.getLocalModule() != null) {
				CommunicationAgent com = Module.getLocalModule().getCommunicationAgent();
				if (com != null) {
					com.shutdown();
				}
			}
			server.disengage();
			server.shutdown(true);
		} // else { thread ends, and main execution is found in CommAgent (Event driven)}
	}

	/**
	 * constructor for an empty Module.
	 */
	public Module() {
		moduleConfig = null;

	}

	/**
	 * constructor for a Module with a configuration.
	 * 
	 * @param confPath
	 *            path to the configuration file
	 * @throws IOException
	 *             if config file not readable
	 */
	public Module(final String confPath) throws IOException {
		if (confPath == null) {
			throw new IllegalArgumentException();
		}
		LOGGER.debug("Loading config file ({})", confPath);

		moduleConfig = new ModuleConfig(new PropertiesConfigFile(confPath));

		canRun = moduleConfig.getSupportedBlockId();
		location = moduleConfig.getLocation();
	}

	/**
	 * constructor for a Module with a configuration File - TESTING ONLY-.
	 * 
	 * @param setConf
	 *            the configuration file to use
	 */
	public Module(final ModuleConfig setConf) {
		LOGGER.debug("Loading TESTconfig file ({})", moduleConfig);
		LOGGER.debug("- TESTING ONLY - function called.");

		moduleConfig = setConf;

		canRun = moduleConfig.getSupportedBlockId();
		location = moduleConfig.getLocation();
	}

	/**
	 * Returns the ModuleConfig for this module.
	 * 
	 * @return the ModuleConfig for this module
	 */
	public ModuleConfig getModuleConfig() {
		return moduleConfig;
	}

	/**
	 * Returns the CommunicationAgent for this module. Returns null if this is not a local module.
	 * 
	 * @return the CommunicatioAgent for this module
	 */
	public CommunicationAgent getCommunicationAgent() {
		return communicationAgent;
	}

	/**
	 * Returns the module ID. This is set by the CommunicationAgent. Before it is set this method will return
	 * 0, which is an invalid id.
	 * 
	 * @return the module ID.
	 */
	public long getID() {
		return id;
	}

	/**
	 * sets the id. Only used once by the Communication agent upon initialisation
	 * 
	 * @param id
	 *            the id to set
	 */
	void setID(final long id) { // package access
		if (this.id != 0L) {
			LOGGER.error("reassigning ID to module.");
		}
		this.id = id;
	}

	/**
	 * Returns a list of FunctionBlock identifiers that can be run on this module. Does not include ids that
	 * are in use.
	 * 
	 * @return a list of FunctionBlock identifiers that can be run on this module
	 * @see #getIsRunning()
	 */
	public synchronized List<String> getCanRun() {
		return canRun;
	}

	/**
	 * Returns a list of FunctionBlock identifiers that are in use.
	 * 
	 * @return a list of FunctionBlock identifiers that are in use
	 * @see #getCanRun()
	 */
	public synchronized List<String> getIsRunning() {
		return isRunning;
	}

	/**
	 * Checks if FunctionBlocks can be run on this module.
	 * 
	 * @param functionBlocks
	 *            the FunctionBlocks to check
	 * @return true if the {@link FunctionBlock} can be run on this module
	 */
	public synchronized boolean canRun(final Collection<FunctionBlock> functionBlocks) {
		LOGGER.entry(functionBlocks);
		if (functionBlocks == null || functionBlocks.isEmpty()) {
			LOGGER.exit(true);
			return true;
		}
		if (functionBlocks.size() > moduleConfig.getMaxNumberOfBlocks() - isRunning.size()) {
			LOGGER.exit(false);
			return false;
		}

		Map<String, Integer> typeCount = new HashMap<>();
		for (FunctionBlock block : functionBlocks) {
			if (block == null) {
				continue;
			}

			String blockPosition = block.getPosition();
			if (blockPosition != null) {

				try {
					if (location == null || !location.matches(blockPosition)) {
						return false;
					}
				} catch (java.util.regex.PatternSyntaxException ex) {
					LOGGER.warn("Illegal regex {}", blockPosition);
					return false;
				}
			}

			String type = block.getType();
			if (type == null) {
				continue;
			}
			if (typeCount.containsKey(type)) {
				typeCount.put(type, typeCount.get(type) + 1);
			} else {
				typeCount.put(type, 1);
			}
		}
		for (Map.Entry<String, Integer> entry : typeCount.entrySet()) {
			if (Collections.frequency(canRun, entry.getKey()) < entry.getValue()) {
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("{} for {} but need {}", Collections.frequency(canRun, entry.getKey()),
							entry.getKey(), entry.getValue());
				}
				LOGGER.exit(false);
				return false;
			}
		}
		LOGGER.exit(true);
		return true;
	}

	/**
	 * whether this module can run the given functionblock.
	 * 
	 * @param functionBlock
	 *            the block to check for
	 * @return whether this module can run the given functionblock
	 */
	public boolean canRun(final FunctionBlock functionBlock) {
		Collection<FunctionBlock> blocks = new ArrayList<>(1);
		blocks.add(functionBlock);
		return canRun(blocks);
	}

	/**
	 * Called when a FunctionBlock is started in an application.
	 * 
	 * @param functionBlock
	 *            the functionBlock to run.
	 * @return true iff the function block is allowed to run on the module.
	 */
	boolean startBlock(final FunctionBlock functionBlock) { // package access
		LOGGER.entry(functionBlock);
		synchronized (this) {
			if (!canRun(functionBlock)) {
				LOGGER.exit(false);
				return false;
			}
			String type = functionBlock.getType();
			if (type != null && !type.isEmpty()) {
				canRun.remove(type);
				isRunning.add(type);
			}
		}

		communicationAgent.moduleChanged();
		LOGGER.exit(true);
		return true;
	}

	/**
	 * Called when a FunctionBlock is stopped in an application.
	 * 
	 * @param funcBlock
	 *            the stopped block
	 */
	void stopBlock(final FunctionBlock funcBlock) { // package access
		synchronized (this) {
			if (!isRunning.contains(funcBlock.getType())) {
				LOGGER.warn("trying to remove block, that was not running on the module.({})",
						funcBlock.getType());
			} else {
				isRunning.remove(funcBlock.getType());
				canRun.add(funcBlock.getType());
			}
			communicationAgent.moduleChanged();
		}
	}

	/**
	 * called by an appAgent upon shutdown.
	 * 
	 * @param appSpaceId
	 *            ID of the application stopped.
	 */
	void stopApplication(final Integer appSpaceId) { // packageAccess
		communicationAgent.stopApplication(appSpaceId);
	}

}
